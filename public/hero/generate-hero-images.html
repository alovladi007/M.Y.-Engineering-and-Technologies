<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hero Image Generator - ABP Photonics</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            background: #1a1a1a; 
            color: white; 
            font-family: Arial, sans-serif; 
        }
        .canvas-container { 
            margin: 20px 0; 
            display: inline-block;
            margin-right: 20px;
        }
        canvas { 
            border: 2px solid #333; 
            display: block; 
            margin: 10px 0; 
        }
        button { 
            padding: 10px 20px; 
            margin: 5px; 
            background: #00CFFF; 
            color: black; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
            font-weight: bold;
        }
        button:hover { 
            background: #00A0CC; 
        }
        h2 {
            color: #00CFFF;
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <h1>Hero Slider Image Generator</h1>
    <p>High-quality placeholder images for all product slides</p>
    
    <div style="display: flex; flex-wrap: wrap;">
        <!-- Microchips -->
        <div class="canvas-container">
            <h3>Microchips</h3>
            <canvas id="microchips" width="1920" height="1080"></canvas>
            <button onclick="downloadCanvas('microchips')">Download</button>
        </div>
        
        <!-- FPGA -->
        <div class="canvas-container">
            <h3>FPGA</h3>
            <canvas id="fpga" width="1920" height="1080"></canvas>
            <button onclick="downloadCanvas('fpga')">Download</button>
        </div>
        
        <!-- Microcontroller -->
        <div class="canvas-container">
            <h3>Microcontroller</h3>
            <canvas id="microcontroller" width="1920" height="1080"></canvas>
            <button onclick="downloadCanvas('microcontroller')">Download</button>
        </div>
        
        <!-- Optics -->
        <div class="canvas-container">
            <h3>Optics</h3>
            <canvas id="optics" width="1920" height="1080"></canvas>
            <button onclick="downloadCanvas('optics')">Download</button>
        </div>
        
        <!-- Photomask -->
        <div class="canvas-container">
            <h3>Photomask</h3>
            <canvas id="photomask" width="1920" height="1080"></canvas>
            <button onclick="downloadCanvas('photomask')">Download</button>
        </div>
    </div>

    <script>
        // Scale canvases for display
        document.querySelectorAll('canvas').forEach(canvas => {
            canvas.style.width = '384px';
            canvas.style.height = '216px';
        });

        // Generate Microchips
        const microchipsCanvas = document.getElementById('microchips');
        const microchipsCtx = microchipsCanvas.getContext('2d');
        
        // Background gradient
        const microchipsGradient = microchipsCtx.createLinearGradient(0, 0, 1920, 1080);
        microchipsGradient.addColorStop(0, '#1e3c72');
        microchipsGradient.addColorStop(1, '#2a5298');
        microchipsCtx.fillStyle = microchipsGradient;
        microchipsCtx.fillRect(0, 0, 1920, 1080);
        
        // Circuit pattern
        microchipsCtx.strokeStyle = '#00CFFF';
        microchipsCtx.lineWidth = 3;
        
        // Draw chip layout
        for (let x = 200; x < 1720; x += 300) {
            for (let y = 200; y < 880; y += 200) {
                // Chip outline
                microchipsCtx.strokeRect(x, y, 250, 150);
                
                // Pin connections
                for (let i = 0; i < 8; i++) {
                    microchipsCtx.beginPath();
                    microchipsCtx.moveTo(x - 20, y + 20 + i * 15);
                    microchipsCtx.lineTo(x, y + 20 + i * 15);
                    microchipsCtx.stroke();
                    
                    microchipsCtx.beginPath();
                    microchipsCtx.moveTo(x + 250, y + 20 + i * 15);
                    microchipsCtx.lineTo(x + 270, y + 20 + i * 15);
                    microchipsCtx.stroke();
                }
                
                // Internal patterns
                microchipsCtx.fillStyle = '#00CFFF';
                microchipsCtx.fillRect(x + 50, y + 50, 150, 50);
                microchipsCtx.fillStyle = '#1e3c72';
                microchipsCtx.font = 'bold 24px Arial';
                microchipsCtx.fillText('ABP', x + 95, y + 85);
            }
        }
        
        // Generate FPGA
        const fpgaCanvas = document.getElementById('fpga');
        const fpgaCtx = fpgaCanvas.getContext('2d');
        
        const fpgaGradient = fpgaCtx.createLinearGradient(0, 0, 1920, 1080);
        fpgaGradient.addColorStop(0, '#2c3e50');
        fpgaGradient.addColorStop(1, '#3498db');
        fpgaCtx.fillStyle = fpgaGradient;
        fpgaCtx.fillRect(0, 0, 1920, 1080);
        
        // FPGA grid pattern
        fpgaCtx.strokeStyle = '#5DADE2';
        fpgaCtx.lineWidth = 2;
        
        // Logic blocks
        for (let x = 100; x < 1820; x += 80) {
            for (let y = 100; y < 980; y += 80) {
                fpgaCtx.strokeRect(x, y, 60, 60);
                
                // Internal routing
                if (Math.random() > 0.3) {
                    fpgaCtx.beginPath();
                    fpgaCtx.moveTo(x + 30, y);
                    fpgaCtx.lineTo(x + 30, y + 60);
                    fpgaCtx.stroke();
                }
                if (Math.random() > 0.3) {
                    fpgaCtx.beginPath();
                    fpgaCtx.moveTo(x, y + 30);
                    fpgaCtx.lineTo(x + 60, y + 30);
                    fpgaCtx.stroke();
                }
                
                // Logic elements
                if (Math.random() > 0.5) {
                    fpgaCtx.fillStyle = '#00CFFF';
                    fpgaCtx.fillRect(x + 20, y + 20, 20, 20);
                }
            }
        }
        
        // Generate Microcontroller
        const mcuCanvas = document.getElementById('microcontroller');
        const mcuCtx = mcuCanvas.getContext('2d');
        
        const mcuGradient = mcuCtx.createLinearGradient(0, 0, 1920, 1080);
        mcuGradient.addColorStop(0, '#1a1a2e');
        mcuGradient.addColorStop(0.5, '#16213e');
        mcuGradient.addColorStop(1, '#0f3460');
        mcuCtx.fillStyle = mcuGradient;
        mcuCtx.fillRect(0, 0, 1920, 1080);
        
        // Draw MCU package
        const centerX = 960;
        const centerY = 540;
        const size = 400;
        
        mcuCtx.fillStyle = '#2a2a2a';
        mcuCtx.fillRect(centerX - size/2, centerY - size/2, size, size);
        
        mcuCtx.strokeStyle = '#00CFFF';
        mcuCtx.lineWidth = 4;
        mcuCtx.strokeRect(centerX - size/2, centerY - size/2, size, size);
        
        // Pins on all sides
        const pinCount = 32;
        const pinSize = 10;
        const pinLength = 40;
        
        mcuCtx.fillStyle = '#silver';
        for (let i = 0; i < pinCount; i++) {
            const offset = (i + 0.5) * (size / pinCount);
            
            // Top pins
            mcuCtx.fillRect(centerX - size/2 + offset - pinSize/2, centerY - size/2 - pinLength, pinSize, pinLength);
            // Bottom pins
            mcuCtx.fillRect(centerX - size/2 + offset - pinSize/2, centerY + size/2, pinSize, pinLength);
            // Left pins
            mcuCtx.fillRect(centerX - size/2 - pinLength, centerY - size/2 + offset - pinSize/2, pinLength, pinSize);
            // Right pins
            mcuCtx.fillRect(centerX + size/2, centerY - size/2 + offset - pinSize/2, pinLength, pinSize);
        }
        
        // Core marking
        mcuCtx.fillStyle = '#00CFFF';
        mcuCtx.font = 'bold 48px Arial';
        mcuCtx.textAlign = 'center';
        mcuCtx.fillText('ABP MCU', centerX, centerY - 20);
        mcuCtx.font = '32px Arial';
        mcuCtx.fillText('ARM Cortex-M7', centerX, centerY + 20);
        mcuCtx.fillText('480MHz', centerX, centerY + 60);
        
        // Generate Optics
        const opticsCanvas = document.getElementById('optics');
        const opticsCtx = opticsCanvas.getContext('2d');
        
        const opticsGradient = opticsCtx.createLinearGradient(0, 0, 1920, 1080);
        opticsGradient.addColorStop(0, '#667eea');
        opticsGradient.addColorStop(1, '#764ba2');
        opticsCtx.fillStyle = opticsGradient;
        opticsCtx.fillRect(0, 0, 1920, 1080);
        
        // Lens system
        opticsCtx.strokeStyle = '#00CFFF';
        opticsCtx.lineWidth = 4;
        
        // Draw multiple lenses
        const lensPositions = [400, 700, 1000, 1300, 1600];
        lensPositions.forEach((x, index) => {
            const radius = 150 - index * 20;
            
            // Lens shape
            opticsCtx.beginPath();
            opticsCtx.arc(x, 540, radius, -Math.PI/3, Math.PI/3);
            opticsCtx.stroke();
            
            opticsCtx.beginPath();
            opticsCtx.arc(x, 540, radius, 2*Math.PI/3, 4*Math.PI/3);
            opticsCtx.stroke();
        });
        
        // Light rays
        opticsCtx.strokeStyle = 'rgba(0, 207, 255, 0.6)';
        opticsCtx.lineWidth = 2;
        
        for (let i = 0; i < 5; i++) {
            const y = 440 + i * 50;
            opticsCtx.beginPath();
            opticsCtx.moveTo(0, y);
            
            lensPositions.forEach((x, index) => {
                opticsCtx.lineTo(x, 540 + (y - 540) * Math.pow(0.8, index));
            });
            
            opticsCtx.lineTo(1920, 540);
            opticsCtx.stroke();
        }
        
        // Generate Photomask
        const photomaskCanvas = document.getElementById('photomask');
        const photomaskCtx = photomaskCanvas.getContext('2d');
        
        const photomaskGradient = photomaskCtx.createLinearGradient(0, 0, 1920, 1080);
        photomaskGradient.addColorStop(0, '#f093fb');
        photomaskGradient.addColorStop(1, '#f5576c');
        photomaskCtx.fillStyle = photomaskGradient;
        photomaskCtx.fillRect(0, 0, 1920, 1080);
        
        // Photomask pattern - geometric precision patterns
        photomaskCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        
        // Create repeating pattern blocks
        for (let x = 200; x < 1720; x += 400) {
            for (let y = 200; y < 880; y += 400) {
                // Main pattern block
                photomaskCtx.fillRect(x, y, 180, 180);
                
                // Cut out patterns
                photomaskCtx.clearRect(x + 20, y + 20, 40, 40);
                photomaskCtx.clearRect(x + 80, y + 20, 80, 20);
                photomaskCtx.clearRect(x + 20, y + 80, 20, 80);
                photomaskCtx.clearRect(x + 60, y + 60, 60, 60);
                photomaskCtx.clearRect(x + 140, y + 80, 20, 80);
                photomaskCtx.clearRect(x + 80, y + 140, 80, 20);
                
                // Alignment marks
                photomaskCtx.strokeStyle = '#000';
                photomaskCtx.lineWidth = 2;
                photomaskCtx.beginPath();
                photomaskCtx.moveTo(x - 20, y + 90);
                photomaskCtx.lineTo(x - 5, y + 90);
                photomaskCtx.moveTo(x + 185, y + 90);
                photomaskCtx.lineTo(x + 200, y + 90);
                photomaskCtx.moveTo(x + 90, y - 20);
                photomaskCtx.lineTo(x + 90, y - 5);
                photomaskCtx.moveTo(x + 90, y + 185);
                photomaskCtx.lineTo(x + 90, y + 200);
                photomaskCtx.stroke();
            }
        }
        
        // Add scale reference
        photomaskCtx.fillStyle = '#000';
        photomaskCtx.font = 'bold 24px Arial';
        photomaskCtx.fillText('10nm Process Technology', 50, 50);
        
        function downloadCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = canvasId + '.jpg';
            link.href = canvas.toDataURL('image/jpeg', 0.95);
            link.click();
        }
        
        // Auto-download all images
        function downloadAll() {
            ['microchips', 'fpga', 'microcontroller', 'optics', 'photomask'].forEach((id, index) => {
                setTimeout(() => downloadCanvas(id), index * 500);
            });
        }
    </script>
    
    <h2>Bulk Download</h2>
    <button onclick="downloadAll()" style="background: #ff6b6b; font-size: 18px; padding: 15px 30px;">
        Download All Images
    </button>
</body>
</html>